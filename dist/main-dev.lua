--[[
-- Hello! This is an example project that bundles the Roblox-TS source into a
-- single file and uploads it to a GitHub release.
--
-- This script was generated by ci/bundle.lua, and should not be modified by hand.
-- To regenerate the code, run 'pnpm bundle' in the root directory.
--
-- Author: 0866
-- Source: https://github.com/richie0866/rbxts-bundle-example
--]]
-- Runtime library
local instances = {}
local modules = {}
local currentlyLoading = {}

local function runModule(object, context)
	currentlyLoading[context] = object

	local currentObject = object
	local depth = 0

	while currentObject do
		depth = depth + 1
		currentObject = currentlyLoading[currentObject]

		if currentObject == object then
			local str = currentObject.Name -- Get the string traceback

			for _ = 1, depth do
				currentObject = currentlyLoading[currentObject]
				str = str .. "  â‡’ " .. currentObject.Name
			end

			error("Failed to load '" .. object.Name .. "'; Detected a circular dependency chain: " .. str, 2)
		end
	end

	local module = modules[object]
	local data = module.callback()

	if currentlyLoading[context] == object then -- Thread-safe cleanup!
		currentlyLoading[context] = nil
	end

	return data
end

local function requireModule(object, context)
	local module = modules[object]

	if module.loaded then
		return module.result
	else
		module.result = runModule(object, context)
		module.loaded = true
		return module.result
	end
end

local function __rbx(name, className, path, parentPath)
	local rbx = Instance.new(className)
	rbx.Name = name
	rbx.Parent = instances[parentPath]
	instances[path] = rbx
	return rbx
end

local function __lua(name, className, path, parentPath, callback)
	local rbx = __rbx(name, className, path, parentPath)

	modules[rbx] = {
		callback = callback,
		result = nil,
		loaded = false,
		globals = {
			script = rbx,
			require = function(object)
				if modules[object] then
					return requireModule(object, rbx)
				else
					return require(object)
				end
			end,
		},
	}
end

local function __env(path)
	return modules[instances[path]].globals
end

local function __start()
	for rbx, module in pairs(modules) do
		if rbx.ClassName == "LocalScript" and not rbx.Disabled then
			task.spawn(module.callback)
		end
	end
end
-- Generated by ci/bundle.lua
__lua("roblox-ts-model", "ModuleScript", "roblox-ts-model", nil, function()
	return assert(loadstring("local _=(...)(\"roblox-ts-model\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.3.0\nlocal TS = require(script.include.RuntimeLib)\nlocal fetchButtons = TS.import(script, script, \"Map\", \"fetchButtons\").default\nlocal fetchCurrentButton = TS.import(script, script, \"Map\", \"fetchCurrentButton\").default\nlocal fetchSpawn = TS.import(script, script, \"Map\", \"fetchSpawn\").default\nlocal _UI = TS.import(script, script, \"UI\")\nlocal newAlert = _UI.newAlert\nlocal newNotification = _UI.newNotification\nlocal API = {}\n-- MAP\nAPI.fetchButtons = function(map)\n\9return fetchButtons(map)\nend\nAPI.fetchCurrentButton = function(map)\n\9return fetchCurrentButton(map)\nend\nAPI.fetchSpawn = function(map)\n\9return fetchSpawn(map)\nend\n-- UI\nAPI.newAlert = function(text, color3, seconds)\n\9return newAlert(text, color3, seconds)\nend\nAPI.newNotification = function(info, title, actionFunc, image)\n\9return newNotification(info, title, actionFunc, image)\nend\nlocal default = API\nreturn {\n\9default = default,\n}", "roblox-ts-model"))(__env)
end)
__lua("General", "ModuleScript", "roblox-ts-model.General", "roblox-ts-model", function()
	return assert(loadstring("local _=(...)(\"roblox-ts-model.General\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.3.0\nlocal TS = require(script.Parent.include.RuntimeLib)\nlocal ReplicatedStorage = TS.import(script, script.Parent, \"include\", \"node_modules\", \"@rbxts\", \"services\").ReplicatedStorage\nlocal Remote = ReplicatedStorage:WaitForChild(\"Remote\")\nlocal function GetPassKey()\n\9local ReqPasskey = Remote:WaitForChild(\"ReqPasskey\")\n\9return -(ReqPasskey:InvokeServer())\nend\nlocal default = {\n\9GetPassKey = GetPassKey,\n}\nreturn {\n\9default = default,\n}", "roblox-ts-model.General"))(__env)
end)
__rbx("Map", "Folder", "roblox-ts-model.Map", "roblox-ts-model")
__lua("fetchButtons", "ModuleScript", "roblox-ts-model.Map.fetchButtons", "roblox-ts-model.Map", function()
	return assert(loadstring("local _=(...)(\"roblox-ts-model.Map.fetchButtons\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.3.0\nlocal function default(map)\n\9local Buttons = {}\n\9for k, v in pairs(map:GetDescendants()) do\n\9\9if v:IsA(\"ImageLabel\") and v.Name == \"ButtonIcon\" then\n\9\9\9local BillboardGui = v.Parent\n\9\9\9if BillboardGui ~= nil then\n\9\9\9\9local ButtonModel = BillboardGui.Parent\n\9\9\9\9if ButtonModel ~= nil and ButtonModel:IsA(\"Model\") then\n\9\9\9\9\9Buttons[ButtonModel] = true\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9end\n\9return Buttons\nend\nreturn {\n\9default = default,\n}", "roblox-ts-model.Map.fetchButtons"))(__env)
end)
__lua("fetchCurrentButton", "ModuleScript", "roblox-ts-model.Map.fetchCurrentButton", "roblox-ts-model.Map", function()
	return assert(loadstring("local _=(...)(\"roblox-ts-model.Map.fetchCurrentButton\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.3.0\nlocal function default(map)\n\9for k, v in pairs(map:GetDescendants()) do\n\9\9if v:IsA(\"ImageLabel\") and v.Name == \"ButtonIcon\" then\n\9\9\9local Green = Color3.new(0, 1, 0)\n\9\9\9local Blue = Color3.new(0, 1, 1)\n\9\9\9if v.ImageColor3 == Green or v.ImageColor3 == Blue then\n\9\9\9\9local BillboardGui = v.Parent\n\9\9\9\9if BillboardGui ~= nil then\n\9\9\9\9\9local ButtonModel = BillboardGui.Parent\n\9\9\9\9\9if ButtonModel ~= nil and ButtonModel:IsA(\"Model\") then\n\9\9\9\9\9\9return ButtonModel\n\9\9\9\9\9end\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9end\n\9return nil\nend\nreturn {\n\9default = default,\n}", "roblox-ts-model.Map.fetchCurrentButton"))(__env)
end)
__lua("fetchSpawn", "ModuleScript", "roblox-ts-model.Map.fetchSpawn", "roblox-ts-model.Map", function()
	return assert(loadstring("local _=(...)(\"roblox-ts-model.Map.fetchSpawn\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.3.0\nlocal function default(map)\n\9local Spawn\n\9for k, v in pairs(map:GetChildren()) do\n\9\9if v:IsA(\"Part\") then\n\9\9\9local YSize = math.floor(v.Size.Y * 10) / 10\n\9\9\9if YSize ~= 0.1 then\n\9\9\9\9continue\n\9\9\9end\n\9\9\9if v.Material ~= Enum.Material.SmoothPlastic then\n\9\9\9\9continue\n\9\9\9end\n\9\9\9Spawn = v\n\9\9\9break\n\9\9end\n\9end\n\9return Spawn\nend\nreturn {\n\9default = default,\n}", "roblox-ts-model.Map.fetchSpawn"))(__env)
end)
__lua("UI", "ModuleScript", "roblox-ts-model.UI", "roblox-ts-model", function()
	return assert(loadstring("local _=(...)(\"roblox-ts-model.UI\")local script,require=_.script,_.require -- Compiled with roblox-ts v2.3.0\nlocal TS = require(script.Parent.include.RuntimeLib)\nlocal Players = TS.import(script, script.Parent, \"include\", \"node_modules\", \"@rbxts\", \"services\").Players\nlocal LocalPlayer = Players.LocalPlayer\nlocal PlayerGui = LocalPlayer:FindFirstChildOfClass(\"PlayerGui\")\nlocal _result = PlayerGui\nif _result ~= nil then\n\9_result = _result:WaitForChild(\"CL_MAIN_GameScript\")\nend\nlocal CL_MAIN_GameScript = _result\nlocal Alert = CL_MAIN_GameScript:WaitForChild(\"Alert\")\nlocal Notify = CL_MAIN_GameScript:WaitForChild(\"Alert\")\nlocal function newAlert(text, color3, seconds)\n\9Alert:Fire(text, color3, seconds)\nend\nlocal function newNotification(info, title, actionFunc, image)\n\9Notify:Fire(info, title, actionFunc, image)\nend\nlocal function updRopeData(data)\n\9-- Fire the updRopeData function;\nend\nreturn {\n\9newAlert = newAlert,\n\9newNotification = newNotification,\n\9updRopeData = updRopeData,\n}", "roblox-ts-model.UI"))(__env)
end)
__rbx("include", "Folder", "roblox-ts-model.include", "roblox-ts-model")
__lua("Promise", "ModuleScript", "roblox-ts-model.include.Promise", "roblox-ts-model.include", function()
	return assert(loadstring("local _=(...)(\"roblox-ts-model.include.Promise\")local script,require=_.script,_.require --[[\n\9An implementation of Promises similar to Promise/A+.\n]]\n\nlocal ERROR_NON_PROMISE_IN_LIST = \"Non-promise value passed into %s at index %s\"\nlocal ERROR_NON_LIST = \"Please pass a list of promises to %s\"\nlocal ERROR_NON_FUNCTION = \"Please pass a handler function to %s!\"\nlocal MODE_KEY_METATABLE = { __mode = \"k\" }\n\nlocal function isCallable(value)\n\9if type(value) == \"function\" then\n\9\9return true\n\9end\n\n\9if type(value) == \"table\" then\n\9\9local metatable = getmetatable(value)\n\9\9if metatable and type(rawget(metatable, \"__call\")) == \"function\" then\n\9\9\9return true\n\9\9end\n\9end\n\n\9return false\nend\n\n--[[\n\9Creates an enum dictionary with some metamethods to prevent common mistakes.\n]]\nlocal function makeEnum(enumName, members)\n\9local enum = {}\n\n\9for _, memberName in ipairs(members) do\n\9\9enum[memberName] = memberName\n\9end\n\n\9return setmetatable(enum, {\n\9\9__index = function(_, k)\n\9\9\9error(string.format(\"%s is not in %s!\", k, enumName), 2)\n\9\9end,\n\9\9__newindex = function()\n\9\9\9error(string.format(\"Creating new members in %s is not allowed!\", enumName), 2)\n\9\9end,\n\9})\nend\n\n--[=[\n\9An object to represent runtime errors that occur during execution.\n\9Promises that experience an error like this will be rejected with\n\9an instance of this object.\n\n\9@class Error\n]=]\nlocal Error\ndo\n\9Error = {\n\9\9Kind = makeEnum(\"Promise.Error.Kind\", {\n\9\9\9\"ExecutionError\",\n\9\9\9\"AlreadyCancelled\",\n\9\9\9\"NotResolvedInTime\",\n\9\9\9\"TimedOut\",\n\9\9}),\n\9}\n\9Error.__index = Error\n\n\9function Error.new(options, parent)\n\9\9options = options or {}\n\9\9return setmetatable({\n\9\9\9error = tostring(options.error) or \"[This error has no error text.]\",\n\9\9\9trace = options.trace,\n\9\9\9context = options.context,\n\9\9\9kind = options.kind,\n\9\9\9parent = parent,\n\9\9\9createdTick = os.clock(),\n\9\9\9createdTrace = debug.traceback(),\n\9\9}, Error)\n\9end\n\n\9function Error.is(anything)\n\9\9if type(anything) == \"table\" then\n\9\9\9local metatable = getmetatable(anything)\n\n\9\9\9if type(metatable) == \"table\" then\n\9\9\9\9return rawget(anything, \"error\") ~= nil and type(rawget(metatable, \"extend\")) == \"function\"\n\9\9\9end\n\9\9end\n\n\9\9return false\n\9end\n\n\9function Error.isKind(anything, kind)\n\9\9assert(kind ~= nil, \"Argument #2 to Promise.Error.isKind must not be nil\")\n\n\9\9return Error.is(anything) and anything.kind == kind\n\9end\n\n\9function Error:extend(options)\n\9\9options = options or {}\n\n\9\9options.kind = options.kind or self.kind\n\n\9\9return Error.new(options, self)\n\9end\n\n\9function Error:getErrorChain()\n\9\9local runtimeErrors = { self }\n\n\9\9while runtimeErrors[#runtimeErrors].parent do\n\9\9\9table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)\n\9\9end\n\n\9\9return runtimeErrors\n\9end\n\n\9function Error:__tostring()\n\9\9local errorStrings = {\n\9\9\9string.format(\"-- Promise.Error(%s) --\", self.kind or \"?\"),\n\9\9}\n\n\9\9for _, runtimeError in ipairs(self:getErrorChain()) do\n\9\9\9table.insert(\n\9\9\9\9errorStrings,\n\9\9\9\9table.concat({\n\9\9\9\9\9runtimeError.trace or runtimeError.error,\n\9\9\9\9\9runtimeError.context,\n\9\9\9\9}, \"\\n\")\n\9\9\9)\n\9\9end\n\n\9\9return table.concat(errorStrings, \"\\n\")\n\9end\nend\n\n--[[\n\9Packs a number of arguments into a table and returns its length.\n\n\9Used to cajole varargs without dropping sparse values.\n]]\nlocal function pack(...)\n\9return select(\"#\", ...), { ... }\nend\n\n--[[\n\9Returns first value (success), and packs all following values.\n]]\nlocal function packResult(success, ...)\n\9return success, select(\"#\", ...), { ... }\nend\n\nlocal function makeErrorHandler(traceback)\n\9assert(traceback ~= nil, \"traceback is nil\")\n\n\9return function(err)\n\9\9-- If the error object is already a table, forward it directly.\n\9\9-- Should we extend the error here and add our own trace?\n\n\9\9if type(err) == \"table\" then\n\9\9\9return err\n\9\9end\n\n\9\9return Error.new({\n\9\9\9error = err,\n\9\9\9kind = Error.Kind.ExecutionError,\n\9\9\9trace = debug.traceback(tostring(err), 2),\n\9\9\9context = \"Promise created at:\\n\\n\" .. traceback,\n\9\9})\n\9end\nend\n\n--[[\n\9Calls a Promise executor with error handling.\n]]\nlocal function runExecutor(traceback, callback, ...)\n\9return packResult(xpcall(callback, makeErrorHandler(traceback), ...))\nend\n\n--[[\n\9Creates a function that invokes a callback with correct error handling and\n\9resolution mechanisms.\n]]\nlocal function createAdvancer(traceback, callback, resolve, reject)\n\9return function(...)\n\9\9local ok, resultLength, result = runExecutor(traceback, callback, ...)\n\n\9\9if ok then\n\9\9\9resolve(unpack(result, 1, resultLength))\n\9\9else\n\9\9\9reject(result[1])\n\9\9end\n\9end\nend\n\nlocal function isEmpty(t)\n\9return next(t) == nil\nend\n\n--[=[\n\9An enum value used to represent the Promise's status.\n\9@interface Status\n\9@tag enum\n\9@within Promise\n\9.Started \"Started\" -- The Promise is executing, and not settled yet.\n\9.Resolved \"Resolved\" -- The Promise finished successfully.\n\9.Rejected \"Rejected\" -- The Promise was rejected.\n\9.Cancelled \"Cancelled\" -- The Promise was cancelled before it finished.\n]=]\n--[=[\n\9@prop Status Status\n\9@within Promise\n\9@readonly\n\9@tag enums\n\9A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.\n]=]\n--[=[\n\9A Promise is an object that represents a value that will exist in the future, but doesn't right now.\n\9Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),\n\9or if an error has occurred (known as *rejecting*).\n\n\9@class Promise\n\9@__index prototype\n]=]\nlocal Promise = {\n\9Error = Error,\n\9Status = makeEnum(\"Promise.Status\", { \"Started\", \"Resolved\", \"Rejected\", \"Cancelled\" }),\n\9_getTime = os.clock,\n\9_timeEvent = game:GetService(\"RunService\").Heartbeat,\n\9_unhandledRejectionCallbacks = {},\n}\nPromise.prototype = {}\nPromise.__index = Promise.prototype\n\nfunction Promise._new(traceback, callback, parent)\n\9if parent ~= nil and not Promise.is(parent) then\n\9\9error(\"Argument #2 to Promise.new must be a promise or nil\", 2)\n\9end\n\n\9local self = {\n\9\9-- Used to locate where a promise was created\n\9\9_source = traceback,\n\n\9\9_status = Promise.Status.Started,\n\n\9\9-- A table containing a list of all results, whether success or failure.\n\9\9-- Only valid if _status is set to something besides Started\n\9\9_values = nil,\n\n\9\9-- Lua doesn't like sparse arrays very much, so we explicitly store the\n\9\9-- length of _values to handle middle nils.\n\9\9_valuesLength = -1,\n\n\9\9-- Tracks if this Promise has no error observers..\n\9\9_unhandledRejection = true,\n\n\9\9-- Queues representing functions we should invoke when we update!\n\9\9_queuedResolve = {},\n\9\9_queuedReject = {},\n\9\9_queuedFinally = {},\n\n\9\9-- The function to run when/if this promise is cancelled.\n\9\9_cancellationHook = nil,\n\n\9\9-- The \"parent\" of this promise in a promise chain. Required for\n\9\9-- cancellation propagation upstream.\n\9\9_parent = parent,\n\n\9\9-- Consumers are Promises that have chained onto this one.\n\9\9-- We track them for cancellation propagation downstream.\n\9\9_consumers = setmetatable({}, MODE_KEY_METATABLE),\n\9}\n\n\9if parent and parent._status == Promise.Status.Started then\n\9\9parent._consumers[self] = true\n\9end\n\n\9setmetatable(self, Promise)\n\n\9local function resolve(...)\n\9\9self:_resolve(...)\n\9end\n\n\9local function reject(...)\n\9\9self:_reject(...)\n\9end\n\n\9local function onCancel(cancellationHook)\n\9\9if cancellationHook then\n\9\9\9if self._status == Promise.Status.Cancelled then\n\9\9\9\9cancellationHook()\n\9\9\9else\n\9\9\9\9self._cancellationHook = cancellationHook\n\9\9\9end\n\9\9end\n\n\9\9return self._status == Promise.Status.Cancelled\n\9end\n\n\9coroutine.wrap(function()\n\9\9local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)\n\n\9\9if not ok then\n\9\9\9reject(result[1])\n\9\9end\n\9end)()\n\n\9return self\nend\n\n--[=[\n\9Construct a new Promise that will be resolved or rejected with the given callbacks.\n\n\9If you `resolve` with a Promise, it will be chained onto.\n\n\9You can safely yield within the executor function and it will not block the creating thread.\n\n\9```lua\n\9local myFunction()\n\9\9return Promise.new(function(resolve, reject, onCancel)\n\9\9\9wait(1)\n\9\9\9resolve(\"Hello world!\")\n\9\9end)\n\9end\n\n\9myFunction():andThen(print)\n\9```\n\n\9You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.\n\n\9You may register an optional cancellation hook by using the `onCancel` argument:\n\n\9* This should be used to abort any ongoing operations leading up to the promise being settled.\n\9* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.\n\9* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.\n\9* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.\n\9* You can set the cancellation hook at any time before resolving.\n\9* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.\n\n\9@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()\n\9@return Promise\n]=]\nfunction Promise.new(executor)\n\9return Promise._new(debug.traceback(nil, 2), executor)\nend\n\nfunction Promise:__tostring()\n\9return string.format(\"Promise(%s)\", self._status)\nend\n\n--[=[\n\9The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.\n\n\9This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.\n\n\9```lua\n\9local function waitForChild(instance, childName, timeout)\n\9  return Promise.defer(function(resolve, reject)\n\9\9local child = instance:WaitForChild(childName, timeout)\n\n\9\9;(child and resolve or reject)(child)\n\9  end)\n\9end\n\9```\n\n\9@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()\n\9@return Promise\n]=]\nfunction Promise.defer(executor)\n\9local traceback = debug.traceback(nil, 2)\n\9local promise\n\9promise = Promise._new(traceback, function(resolve, reject, onCancel)\n\9\9local connection\n\9\9connection = Promise._timeEvent:Connect(function()\n\9\9\9connection:Disconnect()\n\9\9\9local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)\n\n\9\9\9if not ok then\n\9\9\9\9reject(result[1])\n\9\9\9end\n\9\9end)\n\9end)\n\n\9return promise\nend\n\n-- Backwards compatibility\nPromise.async = Promise.defer\n\n--[=[\n\9Creates an immediately resolved Promise with the given value.\n\n\9```lua\n\9-- Example using Promise.resolve to deliver cached values:\n\9function getSomething(name)\n\9\9if cache[name] then\n\9\9\9return Promise.resolve(cache[name])\n\9\9else\n\9\9\9return Promise.new(function(resolve, reject)\n\9\9\9\9local thing = getTheThing()\n\9\9\9\9cache[name] = thing\n\n\9\9\9\9resolve(thing)\n\9\9\9end)\n\9\9end\n\9end\n\9```\n\n\9@param ... any\n\9@return Promise<...any>\n]=]\nfunction Promise.resolve(...)\n\9local length, values = pack(...)\n\9return Promise._new(debug.traceback(nil, 2), function(resolve)\n\9\9resolve(unpack(values, 1, length))\n\9end)\nend\n\n--[=[\n\9Creates an immediately rejected Promise with the given value.\n\n\9:::caution\n\9Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.\n\9:::\n\n\9@param ... any\n\9@return Promise<...any>\n]=]\nfunction Promise.reject(...)\n\9local length, values = pack(...)\n\9return Promise._new(debug.traceback(nil, 2), function(_, reject)\n\9\9reject(unpack(values, 1, length))\n\9end)\nend\n\n--[[\n\9Runs a non-promise-returning function as a Promise with the\n  given arguments.\n]]\nfunction Promise._try(traceback, callback, ...)\n\9local valuesLength, values = pack(...)\n\n\9return Promise._new(traceback, function(resolve)\n\9\9resolve(callback(unpack(values, 1, valuesLength)))\n\9end)\nend\n\n--[=[\n\9Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.\n\n\9:::info\n\9`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.\n\9:::\n\n\9```lua\n\9Promise.try(function()\n\9\9return math.random(1, 2) == 1 and \"ok\" or error(\"Oh an error!\")\n\9end)\n\9\9:andThen(function(text)\n\9\9\9print(text)\n\9\9end)\n\9\9:catch(function(err)\n\9\9\9warn(\"Something went wrong\")\n\9\9end)\n\9```\n\n\9@param callback (...: T...) -> ...any\n\9@param ... T... -- Additional arguments passed to `callback`\n\9@return Promise\n]=]\nfunction Promise.try(callback, ...)\n\9return Promise._try(debug.traceback(nil, 2), callback, ...)\nend\n\n--[[\n\9Returns a new promise that:\n\9\9* is resolved when all input promises resolve\n\9\9* is rejected if ANY input promises reject\n]]\nfunction Promise._all(traceback, promises, amount)\n\9if type(promises) ~= \"table\" then\n\9\9error(string.format(ERROR_NON_LIST, \"Promise.all\"), 3)\n\9end\n\n\9-- We need to check that each value is a promise here so that we can produce\n\9-- a proper error rather than a rejected promise with our error.\n\9for i, promise in pairs(promises) do\n\9\9if not Promise.is(promise) then\n\9\9\9error(string.format(ERROR_NON_PROMISE_IN_LIST, \"Promise.all\", tostring(i)), 3)\n\9\9end\n\9end\n\n\9-- If there are no values then return an already resolved promise.\n\9if #promises == 0 or amount == 0 then\n\9\9return Promise.resolve({})\n\9end\n\n\9return Promise._new(traceback, function(resolve, reject, onCancel)\n\9\9-- An array to contain our resolved values from the given promises.\n\9\9local resolvedValues = {}\n\9\9local newPromises = {}\n\n\9\9-- Keep a count of resolved promises because just checking the resolved\n\9\9-- values length wouldn't account for promises that resolve with nil.\n\9\9local resolvedCount = 0\n\9\9local rejectedCount = 0\n\9\9local done = false\n\n\9\9local function cancel()\n\9\9\9for _, promise in ipairs(newPromises) do\n\9\9\9\9promise:cancel()\n\9\9\9end\n\9\9end\n\n\9\9-- Called when a single value is resolved and resolves if all are done.\n\9\9local function resolveOne(i, ...)\n\9\9\9if done then\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9resolvedCount = resolvedCount + 1\n\n\9\9\9if amount == nil then\n\9\9\9\9resolvedValues[i] = ...\n\9\9\9else\n\9\9\9\9resolvedValues[resolvedCount] = ...\n\9\9\9end\n\n\9\9\9if resolvedCount >= (amount or #promises) then\n\9\9\9\9done = true\n\9\9\9\9resolve(resolvedValues)\n\9\9\9\9cancel()\n\9\9\9end\n\9\9end\n\n\9\9onCancel(cancel)\n\n\9\9-- We can assume the values inside `promises` are all promises since we\n\9\9-- checked above.\n\9\9for i, promise in ipairs(promises) do\n\9\9\9newPromises[i] = promise:andThen(function(...)\n\9\9\9\9resolveOne(i, ...)\n\9\9\9end, function(...)\n\9\9\9\9rejectedCount = rejectedCount + 1\n\n\9\9\9\9if amount == nil or #promises - rejectedCount < amount then\n\9\9\9\9\9cancel()\n\9\9\9\9\9done = true\n\n\9\9\9\9\9reject(...)\n\9\9\9\9end\n\9\9\9end)\n\9\9end\n\n\9\9if done then\n\9\9\9cancel()\n\9\9end\n\9end)\nend\n\n--[=[\n\9Accepts an array of Promises and returns a new promise that:\n\9* is resolved after all input promises resolve.\n\9* is rejected if *any* input promises reject.\n\n\9:::info\n\9Only the first return value from each promise will be present in the resulting array.\n\9:::\n\n\9After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.\n\n\9```lua\n\9local promises = {\n\9\9returnsAPromise(\"example 1\"),\n\9\9returnsAPromise(\"example 2\"),\n\9\9returnsAPromise(\"example 3\"),\n\9}\n\n\9return Promise.all(promises)\n\9```\n\n\9@param promises {Promise<T>}\n\9@return Promise<{T}>\n]=]\nfunction Promise.all(promises)\n\9return Promise._all(debug.traceback(nil, 2), promises)\nend\n\n--[=[\n\9Folds an array of values or promises into a single value. The array is traversed sequentially.\n\n\9The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.\n\n\9The folding will stop at the first rejection encountered.\n\9```lua\n\9local basket = {\"blueberry\", \"melon\", \"pear\", \"melon\"}\n\9Promise.fold(basket, function(cost, fruit)\n\9\9if fruit == \"blueberry\" then\n\9\9\9return cost -- blueberries are free!\n\9\9else\n\9\9\9-- call a function that returns a promise with the fruit price\n\9\9\9return fetchPrice(fruit):andThen(function(fruitCost)\n\9\9\9\9return cost + fruitCost\n\9\9\9end)\n\9\9end\n\9end, 0)\n\9```\n\n\9@since v3.1.0\n\9@param list {T | Promise<T>}\n\9@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>\n\9@param initialValue U\n]=]\nfunction Promise.fold(list, reducer, initialValue)\n\9assert(type(list) == \"table\", \"Bad argument #1 to Promise.fold: must be a table\")\n\9assert(isCallable(reducer), \"Bad argument #2 to Promise.fold: must be a function\")\n\n\9local accumulator = Promise.resolve(initialValue)\n\9return Promise.each(list, function(resolvedElement, i)\n\9\9accumulator = accumulator:andThen(function(previousValueResolved)\n\9\9\9return reducer(previousValueResolved, resolvedElement, i)\n\9\9end)\n\9end):andThen(function()\n\9\9return accumulator\n\9end)\nend\n\n--[=[\n\9Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.\n\n\9`count` 0 results in an empty array. The resultant array will never have more than `count` elements.\n\n\9```lua\n\9local promises = {\n\9\9returnsAPromise(\"example 1\"),\n\9\9returnsAPromise(\"example 2\"),\n\9\9returnsAPromise(\"example 3\"),\n\9}\n\n\9return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve\n\9```\n\n\9@param promises {Promise<T>}\n\9@param count number\n\9@return Promise<{T}>\n]=]\nfunction Promise.some(promises, count)\n\9assert(type(count) == \"number\", \"Bad argument #2 to Promise.some: must be a number\")\n\n\9return Promise._all(debug.traceback(nil, 2), promises, count)\nend\n\n--[=[\n\9Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.\n\n\9Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.\n\n\9```lua\n\9local promises = {\n\9\9returnsAPromise(\"example 1\"),\n\9\9returnsAPromise(\"example 2\"),\n\9\9returnsAPromise(\"example 3\"),\n\9}\n\n\9return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)\n\9```\n\n\9@param promises {Promise<T>}\n\9@return Promise<T>\n]=]\nfunction Promise.any(promises)\n\9return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)\n\9\9return values[1]\n\9end)\nend\n\n--[=[\n\9Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.\n\n\9```lua\n\9local promises = {\n\9\9returnsAPromise(\"example 1\"),\n\9\9returnsAPromise(\"example 2\"),\n\9\9returnsAPromise(\"example 3\"),\n\9}\n\n\9return Promise.allSettled(promises)\n\9```\n\n\9@param promises {Promise<T>}\n\9@return Promise<{Status}>\n]=]\nfunction Promise.allSettled(promises)\n\9if type(promises) ~= \"table\" then\n\9\9error(string.format(ERROR_NON_LIST, \"Promise.allSettled\"), 2)\n\9end\n\n\9-- We need to check that each value is a promise here so that we can produce\n\9-- a proper error rather than a rejected promise with our error.\n\9for i, promise in pairs(promises) do\n\9\9if not Promise.is(promise) then\n\9\9\9error(string.format(ERROR_NON_PROMISE_IN_LIST, \"Promise.allSettled\", tostring(i)), 2)\n\9\9end\n\9end\n\n\9-- If there are no values then return an already resolved promise.\n\9if #promises == 0 then\n\9\9return Promise.resolve({})\n\9end\n\n\9return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)\n\9\9-- An array to contain our resolved values from the given promises.\n\9\9local fates = {}\n\9\9local newPromises = {}\n\n\9\9-- Keep a count of resolved promises because just checking the resolved\n\9\9-- values length wouldn't account for promises that resolve with nil.\n\9\9local finishedCount = 0\n\n\9\9-- Called when a single value is resolved and resolves if all are done.\n\9\9local function resolveOne(i, ...)\n\9\9\9finishedCount = finishedCount + 1\n\n\9\9\9fates[i] = ...\n\n\9\9\9if finishedCount >= #promises then\n\9\9\9\9resolve(fates)\n\9\9\9end\n\9\9end\n\n\9\9onCancel(function()\n\9\9\9for _, promise in ipairs(newPromises) do\n\9\9\9\9promise:cancel()\n\9\9\9end\n\9\9end)\n\n\9\9-- We can assume the values inside `promises` are all promises since we\n\9\9-- checked above.\n\9\9for i, promise in ipairs(promises) do\n\9\9\9newPromises[i] = promise:finally(function(...)\n\9\9\9\9resolveOne(i, ...)\n\9\9\9end)\n\9\9end\n\9end)\nend\n\n--[=[\n\9Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.\n\n\9:::warning\n\9If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.\n\n\9If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.\n\9:::\n\n\9All other Promises that don't win the race will be cancelled if they have no other consumers.\n\n\9```lua\n\9local promises = {\n\9\9returnsAPromise(\"example 1\"),\n\9\9returnsAPromise(\"example 2\"),\n\9\9returnsAPromise(\"example 3\"),\n\9}\n\n\9return Promise.race(promises) -- Only returns 1st value to resolve or reject\n\9```\n\n\9@param promises {Promise<T>}\n\9@return Promise<T>\n]=]\nfunction Promise.race(promises)\n\9assert(type(promises) == \"table\", string.format(ERROR_NON_LIST, \"Promise.race\"))\n\n\9for i, promise in pairs(promises) do\n\9\9assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, \"Promise.race\", tostring(i)))\n\9end\n\n\9return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)\n\9\9local newPromises = {}\n\9\9local finished = false\n\n\9\9local function cancel()\n\9\9\9for _, promise in ipairs(newPromises) do\n\9\9\9\9promise:cancel()\n\9\9\9end\n\9\9end\n\n\9\9local function finalize(callback)\n\9\9\9return function(...)\n\9\9\9\9cancel()\n\9\9\9\9finished = true\n\9\9\9\9return callback(...)\n\9\9\9end\n\9\9end\n\n\9\9if onCancel(finalize(reject)) then\n\9\9\9return\n\9\9end\n\n\9\9for i, promise in ipairs(promises) do\n\9\9\9newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))\n\9\9end\n\n\9\9if finished then\n\9\9\9cancel()\n\9\9end\n\9end)\nend\n\n--[=[\n\9Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.\n\n\9If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item\n\9in the array.\n\n\9:::info\n\9`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.\n\n\9But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.\n\n\9The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.\n\9:::\n\n\9```lua\n\9Promise.each({\n\9\9\"foo\",\n\9\9\"bar\",\n\9\9\"baz\",\n\9\9\"qux\"\n\9}, function(value, index)\n\9\9return Promise.delay(1):andThen(function()\n\9\9print((\"%d) Got %s!\"):format(index, value))\n\9\9end)\n\9end)\n\n\9--[[\n\9\9(1 second passes)\n\9\9> 1) Got foo!\n\9\9(1 second passes)\n\9\9> 2) Got bar!\n\9\9(1 second passes)\n\9\9> 3) Got baz!\n\9\9(1 second passes)\n\9\9> 4) Got qux!\n\9]]\n\9```\n\n\9If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.\n\n\9If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.\n\n\9If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.\n\n\9Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.\n\n\9If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:\n\9- Iteration will not continue.\n\9- Any Promises within the array of values will now be cancelled if they have no other consumers.\n\9- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.\n\n\9@since 3.0.0\n\9@param list {T | Promise<T>}\n\9@param predicate (value: T, index: number) -> U | Promise<U>\n\9@return Promise<{U}>\n]=]\nfunction Promise.each(list, predicate)\n\9assert(type(list) == \"table\", string.format(ERROR_NON_LIST, \"Promise.each\"))\n\9assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, \"Promise.each\"))\n\n\9return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)\n\9\9local results = {}\n\9\9local promisesToCancel = {}\n\n\9\9local cancelled = false\n\n\9\9local function cancel()\n\9\9\9for _, promiseToCancel in ipairs(promisesToCancel) do\n\9\9\9\9promiseToCancel:cancel()\n\9\9\9end\n\9\9end\n\n\9\9onCancel(function()\n\9\9\9cancelled = true\n\n\9\9\9cancel()\n\9\9end)\n\n\9\9-- We need to preprocess the list of values and look for Promises.\n\9\9-- If we find some, we must register our andThen calls now, so that those Promises have a consumer\n\9\9-- from us registered. If we don't do this, those Promises might get cancelled by something else\n\9\9-- before we get to them in the series because it's not possible to tell that we plan to use it\n\9\9-- unless we indicate it here.\n\n\9\9local preprocessedList = {}\n\n\9\9for index, value in ipairs(list) do\n\9\9\9if Promise.is(value) then\n\9\9\9\9if value:getStatus() == Promise.Status.Cancelled then\n\9\9\9\9\9cancel()\n\9\9\9\9\9return reject(Error.new({\n\9\9\9\9\9\9error = \"Promise is cancelled\",\n\9\9\9\9\9\9kind = Error.Kind.AlreadyCancelled,\n\9\9\9\9\9\9context = string.format(\n\9\9\9\9\9\9\9\"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\\n\\nThat Promise was created at:\\n\\n%s\",\n\9\9\9\9\9\9\9index,\n\9\9\9\9\9\9\9value._source\n\9\9\9\9\9\9),\n\9\9\9\9\9}))\n\9\9\9\9elseif value:getStatus() == Promise.Status.Rejected then\n\9\9\9\9\9cancel()\n\9\9\9\9\9return reject(select(2, value:await()))\n\9\9\9\9end\n\n\9\9\9\9-- Chain a new Promise from this one so we only cancel ours\n\9\9\9\9local ourPromise = value:andThen(function(...)\n\9\9\9\9\9return ...\n\9\9\9\9end)\n\n\9\9\9\9table.insert(promisesToCancel, ourPromise)\n\9\9\9\9preprocessedList[index] = ourPromise\n\9\9\9else\n\9\9\9\9preprocessedList[index] = value\n\9\9\9end\n\9\9end\n\n\9\9for index, value in ipairs(preprocessedList) do\n\9\9\9if Promise.is(value) then\n\9\9\9\9local success\n\9\9\9\9success, value = value:await()\n\n\9\9\9\9if not success then\n\9\9\9\9\9cancel()\n\9\9\9\9\9return reject(value)\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9if cancelled then\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9local predicatePromise = Promise.resolve(predicate(value, index))\n\n\9\9\9table.insert(promisesToCancel, predicatePromise)\n\n\9\9\9local success, result = predicatePromise:await()\n\n\9\9\9if not success then\n\9\9\9\9cancel()\n\9\9\9\9return reject(result)\n\9\9\9end\n\n\9\9\9results[index] = result\n\9\9end\n\n\9\9resolve(results)\n\9end)\nend\n\n--[=[\n\9Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.\n\n\9@param object any\n\9@return boolean -- `true` if the given `object` is a Promise.\n]=]\nfunction Promise.is(object)\n\9if type(object) ~= \"table\" then\n\9\9return false\n\9end\n\n\9local objectMetatable = getmetatable(object)\n\n\9if objectMetatable == Promise then\n\9\9-- The Promise came from this library.\n\9\9return true\n\9elseif objectMetatable == nil then\n\9\9-- No metatable, but we should still chain onto tables with andThen methods\n\9\9return isCallable(object.andThen)\n\9elseif\n\9\9type(objectMetatable) == \"table\"\n\9\9and type(rawget(objectMetatable, \"__index\")) == \"table\"\n\9\9and isCallable(rawget(rawget(objectMetatable, \"__index\"), \"andThen\"))\n\9then\n\9\9-- Maybe this came from a different or older Promise library.\n\9\9return true\n\9end\n\n\9return false\nend\n\n--[=[\n\9Wraps a function that yields into one that returns a Promise.\n\n\9Any errors that occur while executing the function will be turned into rejections.\n\n\9:::info\n\9`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.\n\9:::\n\n\9```lua\n\9local sleep = Promise.promisify(wait)\n\n\9sleep(1):andThen(print)\n\9```\n\n\9```lua\n\9local isPlayerInGroup = Promise.promisify(function(player, groupId)\n\9\9return player:IsInGroup(groupId)\n\9end)\n\9```\n\n\9@param callback (...: any) -> ...any\n\9@return (...: any) -> Promise\n]=]\nfunction Promise.promisify(callback)\n\9return function(...)\n\9\9return Promise._try(debug.traceback(nil, 2), callback, ...)\n\9end\nend\n\n--[=[\n\9Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.\n\n\9This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.\n\n\9:::warning\n\9Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.\n\9:::\n\n\9```lua\n\9\9Promise.delay(5):andThenCall(print, \"This prints after 5 seconds\")\n\9```\n\n\9@function delay\n\9@within Promise\n\9@param seconds number\n\9@return Promise<number>\n]=]\ndo\n\9-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert\n\n\9-- the initial node in the linked list\n\9local first\n\9local connection\n\n\9function Promise.delay(seconds)\n\9\9assert(type(seconds) == \"number\", \"Bad argument #1 to Promise.delay, must be a number.\")\n\9\9-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.\n\9\9-- This mirrors the behavior of wait()\n\9\9if not (seconds >= 1 / 60) or seconds == math.huge then\n\9\9\9seconds = 1 / 60\n\9\9end\n\n\9\9return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)\n\9\9\9local startTime = Promise._getTime()\n\9\9\9local endTime = startTime + seconds\n\n\9\9\9local node = {\n\9\9\9\9resolve = resolve,\n\9\9\9\9startTime = startTime,\n\9\9\9\9endTime = endTime,\n\9\9\9}\n\n\9\9\9if connection == nil then -- first is nil when connection is nil\n\9\9\9\9first = node\n\9\9\9\9connection = Promise._timeEvent:Connect(function()\n\9\9\9\9\9local threadStart = Promise._getTime()\n\n\9\9\9\9\9while first ~= nil and first.endTime < threadStart do\n\9\9\9\9\9\9local current = first\n\9\9\9\9\9\9first = current.next\n\n\9\9\9\9\9\9if first == nil then\n\9\9\9\9\9\9\9connection:Disconnect()\n\9\9\9\9\9\9\9connection = nil\n\9\9\9\9\9\9else\n\9\9\9\9\9\9\9first.previous = nil\n\9\9\9\9\9\9end\n\n\9\9\9\9\9\9current.resolve(Promise._getTime() - current.startTime)\n\9\9\9\9\9end\n\9\9\9\9end)\n\9\9\9else -- first is non-nil\n\9\9\9\9if first.endTime < endTime then -- if `node` should be placed after `first`\n\9\9\9\9\9-- we will insert `node` between `current` and `next`\n\9\9\9\9\9-- (i.e. after `current` if `next` is nil)\n\9\9\9\9\9local current = first\n\9\9\9\9\9local next = current.next\n\n\9\9\9\9\9while next ~= nil and next.endTime < endTime do\n\9\9\9\9\9\9current = next\n\9\9\9\9\9\9next = current.next\n\9\9\9\9\9end\n\n\9\9\9\9\9-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)\n\9\9\9\9\9current.next = node\n\9\9\9\9\9node.previous = current\n\n\9\9\9\9\9if next ~= nil then\n\9\9\9\9\9\9node.next = next\n\9\9\9\9\9\9next.previous = node\n\9\9\9\9\9end\n\9\9\9\9else\n\9\9\9\9\9-- set `node` to `first`\n\9\9\9\9\9node.next = first\n\9\9\9\9\9first.previous = node\n\9\9\9\9\9first = node\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9onCancel(function()\n\9\9\9\9-- remove node from queue\n\9\9\9\9local next = node.next\n\n\9\9\9\9if first == node then\n\9\9\9\9\9if next == nil then -- if `node` is the first and last\n\9\9\9\9\9\9connection:Disconnect()\n\9\9\9\9\9\9connection = nil\n\9\9\9\9\9else -- if `node` is `first` and not the last\n\9\9\9\9\9\9next.previous = nil\n\9\9\9\9\9end\n\9\9\9\9\9first = next\n\9\9\9\9else\n\9\9\9\9\9local previous = node.previous\n\9\9\9\9\9-- since `node` is not `first`, then we know `previous` is non-nil\n\9\9\9\9\9previous.next = next\n\n\9\9\9\9\9if next ~= nil then\n\9\9\9\9\9\9next.previous = previous\n\9\9\9\9\9end\n\9\9\9\9end\n\9\9\9end)\n\9\9end)\n\9end\nend\n\n--[=[\n\9Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.\n\n\9Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].\n\n\9```lua\n\9getSomething():timeout(5):andThen(function(something)\n\9\9-- got something and it only took at max 5 seconds\n\9end):catch(function(e)\n\9\9-- Either getting something failed or the time was exceeded.\n\n\9\9if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then\n\9\9\9warn(\"Operation timed out!\")\n\9\9else\n\9\9\9warn(\"Operation encountered an error!\")\n\9\9end\n\9end)\n\9```\n\n\9Sugar for:\n\n\9```lua\n\9Promise.race({\n\9\9Promise.delay(seconds):andThen(function()\n\9\9\9return Promise.reject(\n\9\9\9\9rejectionValue == nil\n\9\9\9\9and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })\n\9\9\9\9or rejectionValue\n\9\9\9)\n\9\9end),\n\9\9promise\n\9})\n\9```\n\n\9@param seconds number\n\9@param rejectionValue? any -- The value to reject with if the timeout is reached\n\9@return Promise\n]=]\nfunction Promise.prototype:timeout(seconds, rejectionValue)\n\9local traceback = debug.traceback(nil, 2)\n\n\9return Promise.race({\n\9\9Promise.delay(seconds):andThen(function()\n\9\9\9return Promise.reject(rejectionValue == nil and Error.new({\n\9\9\9\9kind = Error.Kind.TimedOut,\n\9\9\9\9error = \"Timed out\",\n\9\9\9\9context = string.format(\n\9\9\9\9\9\"Timeout of %d seconds exceeded.\\n:timeout() called at:\\n\\n%s\",\n\9\9\9\9\9seconds,\n\9\9\9\9\9traceback\n\9\9\9\9),\n\9\9\9}) or rejectionValue)\n\9\9end),\n\9\9self,\n\9})\nend\n\n--[=[\n\9Returns the current Promise status.\n\n\9@return Status\n]=]\nfunction Promise.prototype:getStatus()\n\9return self._status\nend\n\n--[[\n\9Creates a new promise that receives the result of this promise.\n\n\9The given callbacks are invoked depending on that result.\n]]\nfunction Promise.prototype:_andThen(traceback, successHandler, failureHandler)\n\9self._unhandledRejection = false\n\n\9-- Create a new promise to follow this part of the chain\n\9return Promise._new(traceback, function(resolve, reject)\n\9\9-- Our default callbacks just pass values onto the next promise.\n\9\9-- This lets success and failure cascade correctly!\n\n\9\9local successCallback = resolve\n\9\9if successHandler then\n\9\9\9successCallback = createAdvancer(traceback, successHandler, resolve, reject)\n\9\9end\n\n\9\9local failureCallback = reject\n\9\9if failureHandler then\n\9\9\9failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)\n\9\9end\n\n\9\9if self._status == Promise.Status.Started then\n\9\9\9-- If we haven't resolved yet, put ourselves into the queue\n\9\9\9table.insert(self._queuedResolve, successCallback)\n\9\9\9table.insert(self._queuedReject, failureCallback)\n\9\9elseif self._status == Promise.Status.Resolved then\n\9\9\9-- This promise has already resolved! Trigger success immediately.\n\9\9\9successCallback(unpack(self._values, 1, self._valuesLength))\n\9\9elseif self._status == Promise.Status.Rejected then\n\9\9\9-- This promise died a terrible death! Trigger failure immediately.\n\9\9\9failureCallback(unpack(self._values, 1, self._valuesLength))\n\9\9elseif self._status == Promise.Status.Cancelled then\n\9\9\9-- We don't want to call the success handler or the failure handler,\n\9\9\9-- we just reject this promise outright.\n\9\9\9reject(Error.new({\n\9\9\9\9error = \"Promise is cancelled\",\n\9\9\9\9kind = Error.Kind.AlreadyCancelled,\n\9\9\9\9context = \"Promise created at\\n\\n\" .. traceback,\n\9\9\9}))\n\9\9end\n\9end, self)\nend\n\n--[=[\n\9Chains onto an existing Promise and returns a new Promise.\n\n\9:::warning\n\9Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.\n\9:::\n\n\9Return a Promise from the success or failure handler and it will be chained onto.\n\n\9@param successHandler (...: any) -> ...any\n\9@param failureHandler? (...: any) -> ...any\n\9@return Promise<...any>\n]=]\nfunction Promise.prototype:andThen(successHandler, failureHandler)\n\9assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, \"Promise:andThen\"))\n\9assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, \"Promise:andThen\"))\n\n\9return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)\nend\n\n--[=[\n\9Shorthand for `Promise:andThen(nil, failureHandler)`.\n\n\9Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.\n\n\9:::warning\n\9Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.\n\9:::\n\n\n\9@param failureHandler (...: any) -> ...any\n\9@return Promise<...any>\n]=]\nfunction Promise.prototype:catch(failureHandler)\n\9assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, \"Promise:catch\"))\n\9return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)\nend\n\n--[=[\n\9Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.\n\n\9```lua\n\9\9getTheValue()\n\9\9:tap(print)\n\9\9:andThen(function(theValue)\n\9\9\9print(\"Got\", theValue, \"even though print returns nil!\")\n\9\9end)\n\9```\n\n\9If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.\n\n\9@param tapHandler (...: any) -> ...any\n\9@return Promise<...any>\n]=]\nfunction Promise.prototype:tap(tapHandler)\n\9assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, \"Promise:tap\"))\n\9return self:_andThen(debug.traceback(nil, 2), function(...)\n\9\9local callbackReturn = tapHandler(...)\n\n\9\9if Promise.is(callbackReturn) then\n\9\9\9local length, values = pack(...)\n\9\9\9return callbackReturn:andThen(function()\n\9\9\9\9return unpack(values, 1, length)\n\9\9\9end)\n\9\9end\n\n\9\9return ...\n\9end)\nend\n\n--[=[\n\9Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.\n\n\9```lua\n\9\9promise:andThenCall(someFunction, \"some\", \"arguments\")\n\9```\n\n\9This is sugar for\n\n\9```lua\n\9\9promise:andThen(function()\n\9\9return someFunction(\"some\", \"arguments\")\n\9\9end)\n\9```\n\n\9@param callback (...: any) -> any\n\9@param ...? any -- Additional arguments which will be passed to `callback`\n\9@return Promise\n]=]\nfunction Promise.prototype:andThenCall(callback, ...)\n\9assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, \"Promise:andThenCall\"))\n\9local length, values = pack(...)\n\9return self:_andThen(debug.traceback(nil, 2), function()\n\9\9return callback(unpack(values, 1, length))\n\9end)\nend\n\n--[=[\n\9Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.\n\n\9```lua\n\9\9promise:andThenReturn(\"some\", \"values\")\n\9```\n\n\9This is sugar for\n\n\9```lua\n\9\9promise:andThen(function()\n\9\9\9return \"some\", \"values\"\n\9\9end)\n\9```\n\n\9:::caution\n\9Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].\n\9:::\n\n\9@param ... any -- Values to return from the function\n\9@return Promise\n]=]\nfunction Promise.prototype:andThenReturn(...)\n\9local length, values = pack(...)\n\9return self:_andThen(debug.traceback(nil, 2), function()\n\9\9return unpack(values, 1, length)\n\9end)\nend\n\n--[=[\n\9Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.\n\n\9Cancellations will propagate upwards and downwards through chained promises.\n\n\9Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.\n\n\9```lua\n\9\9promise:cancel()\n\9```\n]=]\nfunction Promise.prototype:cancel()\n\9if self._status ~= Promise.Status.Started then\n\9\9return\n\9end\n\n\9self._status = Promise.Status.Cancelled\n\n\9if self._cancellationHook then\n\9\9self._cancellationHook()\n\9end\n\n\9if self._parent then\n\9\9self._parent:_consumerCancelled(self)\n\9end\n\n\9for child in pairs(self._consumers) do\n\9\9child:cancel()\n\9end\n\n\9self:_finalize()\nend\n\n--[[\n\9Used to decrease the number of consumers by 1, and if there are no more,\n\9cancel this promise.\n]]\nfunction Promise.prototype:_consumerCancelled(consumer)\n\9if self._status ~= Promise.Status.Started then\n\9\9return\n\9end\n\n\9self._consumers[consumer] = nil\n\n\9if next(self._consumers) == nil then\n\9\9self:cancel()\n\9end\nend\n\n--[[\n\9Used to set a handler for when the promise resolves, rejects, or is\n\9cancelled. Returns a new promise chained from this promise.\n]]\nfunction Promise.prototype:_finally(traceback, finallyHandler, onlyOk)\n\9if not onlyOk then\n\9\9self._unhandledRejection = false\n\9end\n\n\9-- Return a promise chained off of this promise\n\9return Promise._new(traceback, function(resolve, reject)\n\9\9local finallyCallback = resolve\n\9\9if finallyHandler then\n\9\9\9finallyCallback = createAdvancer(traceback, finallyHandler, resolve, reject)\n\9\9end\n\n\9\9if onlyOk then\n\9\9\9local callback = finallyCallback\n\9\9\9finallyCallback = function(...)\n\9\9\9\9if self._status == Promise.Status.Rejected then\n\9\9\9\9\9return resolve(self)\n\9\9\9\9end\n\n\9\9\9\9return callback(...)\n\9\9\9end\n\9\9end\n\n\9\9if self._status == Promise.Status.Started then\n\9\9\9-- The promise is not settled, so queue this.\n\9\9\9table.insert(self._queuedFinally, finallyCallback)\n\9\9else\n\9\9\9-- The promise already settled or was cancelled, run the callback now.\n\9\9\9finallyCallback(self._status)\n\9\9end\n\9end, self)\nend\n\n--[=[\n\9Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, *or* cancelled.\n\n\9Returns a new promise chained from this promise.\n\n\9:::caution\n\9If the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `finally` or `done` will run in the case of cancellation.\n\9:::\n\n\9```lua\n\9local thing = createSomething()\n\n\9doSomethingWith(thing)\n\9\9:andThen(function()\n\9\9\9print(\"It worked!\")\n\9\9\9-- do something..\n\9\9end)\n\9\9:catch(function()\n\9\9\9warn(\"Oh no it failed!\")\n\9\9end)\n\9\9:finally(function()\n\9\9\9-- either way, destroy thing\n\n\9\9\9thing:Destroy()\n\9\9end)\n\n\9```\n\n\9@param finallyHandler (status: Status) -> ...any\n\9@return Promise<...any>\n]=]\nfunction Promise.prototype:finally(finallyHandler)\n\9assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, \"Promise:finally\"))\n\9return self:_finally(debug.traceback(nil, 2), finallyHandler)\nend\n\n--[=[\n\9Same as `andThenCall`, except for `finally`.\n\n\9Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.\n\n\9@param callback (...: any) -> any\n\9@param ...? any -- Additional arguments which will be passed to `callback`\n\9@return Promise\n]=]\nfunction Promise.prototype:finallyCall(callback, ...)\n\9assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, \"Promise:finallyCall\"))\n\9local length, values = pack(...)\n\9return self:_finally(debug.traceback(nil, 2), function()\n\9\9return callback(unpack(values, 1, length))\n\9end)\nend\n\n--[=[\n\9Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.\n\n\9```lua\n\9\9promise:finallyReturn(\"some\", \"values\")\n\9```\n\n\9This is sugar for\n\n\9```lua\n\9\9promise:finally(function()\n\9\9\9return \"some\", \"values\"\n\9\9end)\n\9```\n\n\9@param ... any -- Values to return from the function\n\9@return Promise\n]=]\nfunction Promise.prototype:finallyReturn(...)\n\9local length, values = pack(...)\n\9return self:_finally(debug.traceback(nil, 2), function()\n\9\9return unpack(values, 1, length)\n\9end)\nend\n\n--[=[\n\9Set a handler that will be called only if the Promise resolves or is cancelled. This method is similar to `finally`, except it doesn't catch rejections.\n\n\9:::caution\n\9`done` should be reserved specifically when you want to perform some operation after the Promise is finished (like `finally`), but you don't want to consume rejections (like in <a href=\"/roblox-lua-promise/lib/Examples.html#cancellable-animation-sequence\">this example</a>). You should use `andThen` instead if you only care about the Resolved case.\n\9:::\n\n\9:::warning\n\9Like `finally`, if the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `done` and `finally` will run in the case of cancellation.\n\9:::\n\n\9Returns a new promise chained from this promise.\n\n\9@param doneHandler (status: Status) -> ...any\n\9@return Promise<...any>\n]=]\nfunction Promise.prototype:done(doneHandler)\n\9assert(doneHandler == nil or isCallable(doneHandler), string.format(ERROR_NON_FUNCTION, \"Promise:done\"))\n\9return self:_finally(debug.traceback(nil, 2), doneHandler, true)\nend\n\n--[=[\n\9Same as `andThenCall`, except for `done`.\n\n\9Attaches a `done` handler to this Promise that calls the given callback with the predefined arguments.\n\n\9@param callback (...: any) -> any\n\9@param ...? any -- Additional arguments which will be passed to `callback`\n\9@return Promise\n]=]\nfunction Promise.prototype:doneCall(callback, ...)\n\9assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, \"Promise:doneCall\"))\n\9local length, values = pack(...)\n\9return self:_finally(debug.traceback(nil, 2), function()\n\9\9return callback(unpack(values, 1, length))\n\9end, true)\nend\n\n--[=[\n\9Attaches a `done` handler to this Promise that discards the resolved value and returns the given value from it.\n\n\9```lua\n\9\9promise:doneReturn(\"some\", \"values\")\n\9```\n\n\9This is sugar for\n\n\9```lua\n\9\9promise:done(function()\n\9\9\9return \"some\", \"values\"\n\9\9end)\n\9```\n\n\9@param ... any -- Values to return from the function\n\9@return Promise\n]=]\nfunction Promise.prototype:doneReturn(...)\n\9local length, values = pack(...)\n\9return self:_finally(debug.traceback(nil, 2), function()\n\9\9return unpack(values, 1, length)\n\9end, true)\nend\n\n--[=[\n\9Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.\n\n\9@yields\n\9@return Status -- The Status representing the fate of the Promise\n\9@return ...any -- The values the Promise resolved or rejected with.\n]=]\nfunction Promise.prototype:awaitStatus()\n\9self._unhandledRejection = false\n\n\9if self._status == Promise.Status.Started then\n\9\9local bindable = Instance.new(\"BindableEvent\")\n\n\9\9self:finally(function()\n\9\9\9bindable:Fire()\n\9\9end)\n\n\9\9bindable.Event:Wait()\n\9\9bindable:Destroy()\n\9end\n\n\9if self._status == Promise.Status.Resolved then\n\9\9return self._status, unpack(self._values, 1, self._valuesLength)\n\9elseif self._status == Promise.Status.Rejected then\n\9\9return self._status, unpack(self._values, 1, self._valuesLength)\n\9end\n\n\9return self._status\nend\n\nlocal function awaitHelper(status, ...)\n\9return status == Promise.Status.Resolved, ...\nend\n\n--[=[\n\9Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.\n\n\9:::caution\n\9If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.\n\9:::\n\n\9```lua\n\9\9local worked, value = getTheValue():await()\n\n\9if worked then\n\9\9print(\"got\", value)\n\9else\n\9\9warn(\"it failed\")\n\9end\n\9```\n\n\9@yields\n\9@return boolean -- `true` if the Promise successfully resolved\n\9@return ...any -- The values the Promise resolved or rejected with.\n]=]\nfunction Promise.prototype:await()\n\9return awaitHelper(self:awaitStatus())\nend\n\nlocal function expectHelper(status, ...)\n\9if status ~= Promise.Status.Resolved then\n\9\9error((...) == nil and \"Expected Promise rejected with no value.\" or (...), 3)\n\9end\n\n\9return ...\nend\n\n--[=[\n\9Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.\n\n\9```lua\n\9local worked = pcall(function()\n\9\9print(\"got\", getTheValue():expect())\n\9end)\n\n\9if not worked then\n\9\9warn(\"it failed\")\n\9end\n\9```\n\n\9This is essentially sugar for:\n\n\9```lua\n\9select(2, assert(promise:await()))\n\9```\n\n\9**Errors** if the Promise rejects or gets cancelled.\n\n\9@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.\n\9@yields\n\9@return ...any -- The values the Promise resolved with.\n]=]\nfunction Promise.prototype:expect()\n\9return expectHelper(self:awaitStatus())\nend\n\n-- Backwards compatibility\nPromise.prototype.awaitValue = Promise.prototype.expect\n\n--[[\n\9Intended for use in tests.\n\n\9Similar to await(), but instead of yielding if the promise is unresolved,\n\9_unwrap will throw. This indicates an assumption that a promise has\n\9resolved.\n]]\nfunction Promise.prototype:_unwrap()\n\9if self._status == Promise.Status.Started then\n\9\9error(\"Promise has not resolved or rejected.\", 2)\n\9end\n\n\9local success = self._status == Promise.Status.Resolved\n\n\9return success, unpack(self._values, 1, self._valuesLength)\nend\n\nfunction Promise.prototype:_resolve(...)\n\9if self._status ~= Promise.Status.Started then\n\9\9if Promise.is((...)) then\n\9\9\9(...):_consumerCancelled(self)\n\9\9end\n\9\9return\n\9end\n\n\9-- If the resolved value was a Promise, we chain onto it!\n\9if Promise.is((...)) then\n\9\9-- Without this warning, arguments sometimes mysteriously disappear\n\9\9if select(\"#\", ...) > 1 then\n\9\9\9local message = string.format(\n\9\9\9\9\"When returning a Promise from andThen, extra arguments are \" .. \"discarded! See:\\n\\n%s\",\n\9\9\9\9self._source\n\9\9\9)\n\9\9\9warn(message)\n\9\9end\n\n\9\9local chainedPromise = ...\n\n\9\9local promise = chainedPromise:andThen(function(...)\n\9\9\9self:_resolve(...)\n\9\9end, function(...)\n\9\9\9local maybeRuntimeError = chainedPromise._values[1]\n\n\9\9\9-- Backwards compatibility < v2\n\9\9\9if chainedPromise._error then\n\9\9\9\9maybeRuntimeError = Error.new({\n\9\9\9\9\9error = chainedPromise._error,\n\9\9\9\9\9kind = Error.Kind.ExecutionError,\n\9\9\9\9\9context = \"[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]\",\n\9\9\9\9})\n\9\9\9end\n\n\9\9\9if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then\n\9\9\9\9return self:_reject(maybeRuntimeError:extend({\n\9\9\9\9\9error = \"This Promise was chained to a Promise that errored.\",\n\9\9\9\9\9trace = \"\",\n\9\9\9\9\9context = string.format(\n\9\9\9\9\9\9\"The Promise at:\\n\\n%s\\n...Rejected because it was chained to the following Promise, which encountered an error:\\n\",\n\9\9\9\9\9\9self._source\n\9\9\9\9\9),\n\9\9\9\9}))\n\9\9\9end\n\n\9\9\9self:_reject(...)\n\9\9end)\n\n\9\9if promise._status == Promise.Status.Cancelled then\n\9\9\9self:cancel()\n\9\9elseif promise._status == Promise.Status.Started then\n\9\9\9-- Adopt ourselves into promise for cancellation propagation.\n\9\9\9self._parent = promise\n\9\9\9promise._consumers[self] = true\n\9\9end\n\n\9\9return\n\9end\n\n\9self._status = Promise.Status.Resolved\n\9self._valuesLength, self._values = pack(...)\n\n\9-- We assume that these callbacks will not throw errors.\n\9for _, callback in ipairs(self._queuedResolve) do\n\9\9coroutine.wrap(callback)(...)\n\9end\n\n\9self:_finalize()\nend\n\nfunction Promise.prototype:_reject(...)\n\9if self._status ~= Promise.Status.Started then\n\9\9return\n\9end\n\n\9self._status = Promise.Status.Rejected\n\9self._valuesLength, self._values = pack(...)\n\n\9-- If there are any rejection handlers, call those!\n\9if not isEmpty(self._queuedReject) then\n\9\9-- We assume that these callbacks will not throw errors.\n\9\9for _, callback in ipairs(self._queuedReject) do\n\9\9\9coroutine.wrap(callback)(...)\n\9\9end\n\9else\n\9\9-- At this point, no one was able to observe the error.\n\9\9-- An error handler might still be attached if the error occurred\n\9\9-- synchronously. We'll wait one tick, and if there are still no\n\9\9-- observers, then we should put a message in the console.\n\n\9\9local err = tostring((...))\n\n\9\9coroutine.wrap(function()\n\9\9\9Promise._timeEvent:Wait()\n\n\9\9\9-- Someone observed the error, hooray!\n\9\9\9if not self._unhandledRejection then\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9-- Build a reasonable message\n\9\9\9local message = string.format(\"Unhandled Promise rejection:\\n\\n%s\\n\\n%s\", err, self._source)\n\n\9\9\9for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do\n\9\9\9\9task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))\n\9\9\9end\n\n\9\9\9if Promise.TEST then\n\9\9\9\9-- Don't spam output when we're running tests.\n\9\9\9\9return\n\9\9\9end\n\n\9\9\9warn(message)\n\9\9end)()\n\9end\n\n\9self:_finalize()\nend\n\n--[[\n\9Calls any :finally handlers. We need this to be a separate method and\n\9queue because we must call all of the finally callbacks upon a success,\n\9failure, *and* cancellation.\n]]\nfunction Promise.prototype:_finalize()\n\9for _, callback in ipairs(self._queuedFinally) do\n\9\9-- Purposefully not passing values to callbacks here, as it could be the\n\9\9-- resolved values, or rejected errors. If the developer needs the values,\n\9\9-- they should use :andThen or :catch explicitly.\n\9\9coroutine.wrap(callback)(self._status)\n\9end\n\n\9self._queuedFinally = nil\n\9self._queuedReject = nil\n\9self._queuedResolve = nil\n\n\9-- Clear references to other Promises to allow gc\n\9if not Promise.TEST then\n\9\9self._parent = nil\n\9\9self._consumers = nil\n\9end\nend\n\n--[=[\n\9Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.\n\n\9```lua\n\9doSomething()\n\9\9:now()\n\9\9:andThen(function(value)\n\9\9\9print(\"Got\", value, \"synchronously.\")\n\9\9end)\n\9```\n\n\9If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].\n\n\9@param rejectionValue? any -- The value to reject with if the Promise isn't resolved\n\9@return Promise\n]=]\nfunction Promise.prototype:now(rejectionValue)\n\9local traceback = debug.traceback(nil, 2)\n\9if self._status == Promise.Status.Resolved then\n\9\9return self:_andThen(traceback, function(...)\n\9\9\9return ...\n\9\9end)\n\9else\n\9\9return Promise.reject(rejectionValue == nil and Error.new({\n\9\9\9kind = Error.Kind.NotResolvedInTime,\n\9\9\9error = \"This Promise was not resolved in time for :now()\",\n\9\9\9context = \":now() was called at:\\n\\n\" .. traceback,\n\9\9}) or rejectionValue)\n\9end\nend\n\n--[=[\n\9Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.\n\n\9If the amount of retries is exceeded, the function will return the latest rejected Promise.\n\n\9```lua\n\9local function canFail(a, b, c)\n\9\9return Promise.new(function(resolve, reject)\n\9\9\9-- do something that can fail\n\n\9\9\9local failed, thing = doSomethingThatCanFail(a, b, c)\n\n\9\9\9if failed then\n\9\9\9\9reject(\"it failed\")\n\9\9\9else\n\9\9\9\9resolve(thing)\n\9\9\9end\n\9\9end)\n\9end\n\n\9local MAX_RETRIES = 10\n\9local value = Promise.retry(canFail, MAX_RETRIES, \"foo\", \"bar\", \"baz\") -- args to send to canFail\n\9```\n\n\9@since 3.0.0\n\9@param callback (...: P) -> Promise<T>\n\9@param times number\n\9@param ...? P\n]=]\nfunction Promise.retry(callback, times, ...)\n\9assert(isCallable(callback), \"Parameter #1 to Promise.retry must be a function\")\n\9assert(type(times) == \"number\", \"Parameter #2 to Promise.retry must be a number\")\n\n\9local args, length = { ... }, select(\"#\", ...)\n\n\9return Promise.resolve(callback(...)):catch(function(...)\n\9\9if times > 0 then\n\9\9\9return Promise.retry(callback, times - 1, unpack(args, 1, length))\n\9\9else\n\9\9\9return Promise.reject(...)\n\9\9end\n\9end)\nend\n\n--[=[\n\9Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each\n\9retry, until the returned Promise resolves.\n\n\9If the amount of retries is exceeded, the function will return the latest rejected Promise.\n\n\9@since v3.2.0\n\9@param callback (...: P) -> Promise<T>\n\9@param times number\n\9@param seconds number\n\9@param ...? P\n]=]\nfunction Promise.retryWithDelay(callback, times, seconds, ...)\n\9assert(isCallable(callback), \"Parameter #1 to Promise.retry must be a function\")\n\9assert(type(times) == \"number\", \"Parameter #2 (times) to Promise.retry must be a number\")\n\9assert(type(seconds) == \"number\", \"Parameter #3 (seconds) to Promise.retry must be a number\")\n\n\9local args, length = { ... }, select(\"#\", ...)\n\n\9return Promise.resolve(callback(...)):catch(function(...)\n\9\9if times > 0 then\n\9\9\9Promise.delay(seconds):await()\n\n\9\9\9return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))\n\9\9else\n\9\9\9return Promise.reject(...)\n\9\9end\n\9end)\nend\n\n--[=[\n\9Converts an event into a Promise which resolves the next time the event fires.\n\n\9The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.\n\n\9The Promise will resolve with the event arguments.\n\n\9:::tip\n\9This function will work given any object with a `Connect` method. This includes all Roblox events.\n\9:::\n\n\9```lua\n\9-- Creates a Promise which only resolves when `somePart` is touched\n\9-- by a part named `\"Something specific\"`.\n\9return Promise.fromEvent(somePart.Touched, function(part)\n\9\9return part.Name == \"Something specific\"\n\9end)\n\9```\n\n\9@since 3.0.0\n\9@param event Event -- Any object with a `Connect` method. This includes all Roblox events.\n\9@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.\n\9@return Promise<P>\n]=]\nfunction Promise.fromEvent(event, predicate)\n\9predicate = predicate or function()\n\9\9return true\n\9end\n\n\9return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)\n\9\9local connection\n\9\9local shouldDisconnect = false\n\n\9\9local function disconnect()\n\9\9\9connection:Disconnect()\n\9\9\9connection = nil\n\9\9end\n\n\9\9-- We use shouldDisconnect because if the callback given to Connect is called before\n\9\9-- Connect returns, connection will still be nil. This happens with events that queue up\n\9\9-- events when there's nothing connected, such as RemoteEvents\n\n\9\9connection = event:Connect(function(...)\n\9\9\9local callbackValue = predicate(...)\n\n\9\9\9if callbackValue == true then\n\9\9\9\9resolve(...)\n\n\9\9\9\9if connection then\n\9\9\9\9\9disconnect()\n\9\9\9\9else\n\9\9\9\9\9shouldDisconnect = true\n\9\9\9\9end\n\9\9\9elseif type(callbackValue) ~= \"boolean\" then\n\9\9\9\9error(\"Promise.fromEvent predicate should always return a boolean\")\n\9\9\9end\n\9\9end)\n\n\9\9if shouldDisconnect and connection then\n\9\9\9return disconnect()\n\9\9end\n\n\9\9onCancel(disconnect)\n\9end)\nend\n\n--[=[\n\9Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise\n\9is rejected, and the rejection is not observed with `:catch`.\n\n\9The callback is called with the actual promise that rejected, followed by the rejection values.\n\n\9@since v3.2.0\n\9@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.\n\9@return () -> () -- Function that unregisters the `callback` when called\n]=]\nfunction Promise.onUnhandledRejection(callback)\n\9table.insert(Promise._unhandledRejectionCallbacks, callback)\n\n\9return function()\n\9\9local index = table.find(Promise._unhandledRejectionCallbacks, callback)\n\n\9\9if index then\n\9\9\9table.remove(Promise._unhandledRejectionCallbacks, index)\n\9\9end\n\9end\nend\n\nreturn Promise", "roblox-ts-model.include.Promise"))(__env)
end)
__lua("RuntimeLib", "ModuleScript", "roblox-ts-model.include.RuntimeLib", "roblox-ts-model.include", function()
	return assert(loadstring("local _=(...)(\"roblox-ts-model.include.RuntimeLib\")local script,require=_.script,_.require local Promise = require(script.Parent.Promise)\n\nlocal RunService = game:GetService(\"RunService\")\n\nlocal OUTPUT_PREFIX = \"roblox-ts: \"\nlocal NODE_MODULES = \"node_modules\"\nlocal DEFAULT_SCOPE = \"@rbxts\"\n\nlocal TS = {}\n\nTS.Promise = Promise\n\nlocal function isPlugin(context)\n\9return RunService:IsStudio() and context:FindFirstAncestorWhichIsA(\"Plugin\") ~= nil\nend\n\nfunction TS.getModule(context, scope, moduleName)\n\9-- legacy call signature\n\9if moduleName == nil then\n\9\9moduleName = scope\n\9\9scope = DEFAULT_SCOPE\n\9end\n\n\9-- ensure modules have fully replicated\n\9if RunService:IsRunning() and RunService:IsClient() and not isPlugin(context) and not game:IsLoaded() then\n\9\9game.Loaded:Wait()\n\9end\n\n\9local object = context\n\9repeat\n\9\9local nodeModulesFolder = object:FindFirstChild(NODE_MODULES)\n\9\9if nodeModulesFolder then\n\9\9\9local scopeFolder = nodeModulesFolder:FindFirstChild(scope)\n\9\9\9if scopeFolder then\n\9\9\9\9local module = scopeFolder:FindFirstChild(moduleName)\n\9\9\9\9if module then\n\9\9\9\9\9return module\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9\9object = object.Parent\n\9until object == nil\n\n\9error(OUTPUT_PREFIX .. \"Could not find module: \" .. moduleName, 2)\nend\n\n-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library\nlocal currentlyLoading = {}\nlocal registeredLibraries = {}\n\nfunction TS.import(context, module, ...)\n\9for i = 1, select(\"#\", ...) do\n\9\9module = module:WaitForChild((select(i, ...)))\n\9end\n\n\9if module.ClassName ~= \"ModuleScript\" then\n\9\9error(OUTPUT_PREFIX .. \"Failed to import! Expected ModuleScript, got \" .. module.ClassName, 2)\n\9end\n\n\9currentlyLoading[context] = module\n\n\9-- Check to see if a case like this occurs:\n\9-- module -> Module1 -> Module2 -> module\n\n\9-- WHERE currentlyLoading[module] is Module1\n\9-- and currentlyLoading[Module1] is Module2\n\9-- and currentlyLoading[Module2] is module\n\n\9local currentModule = module\n\9local depth = 0\n\n\9while currentModule do\n\9\9depth = depth + 1\n\9\9currentModule = currentlyLoading[currentModule]\n\n\9\9if currentModule == module then\n\9\9\9local str = currentModule.Name -- Get the string traceback\n\n\9\9\9for _ = 1, depth do\n\9\9\9\9currentModule = currentlyLoading[currentModule]\n\9\9\9\9str = str .. \"  â‡’ \" .. currentModule.Name\n\9\9\9end\n\n\9\9\9error(OUTPUT_PREFIX .. \"Failed to import! Detected a circular dependency chain: \" .. str, 2)\n\9\9end\n\9end\n\n\9if not registeredLibraries[module] then\n\9\9if _G[module] then\n\9\9\9error(\n\9\9\9\9OUTPUT_PREFIX\n\9\9\9\9.. \"Invalid module access! Do you have multiple TS runtimes trying to import this? \"\n\9\9\9\9.. module:GetFullName(),\n\9\9\9\0092\n\9\9\9)\n\9\9end\n\n\9\9_G[module] = TS\n\9\9registeredLibraries[module] = true -- register as already loaded for subsequent calls\n\9end\n\n\9local data = require(module)\n\n\9if currentlyLoading[context] == module then -- Thread-safe cleanup!\n\9\9currentlyLoading[context] = nil\n\9end\n\n\9return data\nend\n\nfunction TS.instanceof(obj, class)\n\9-- custom Class.instanceof() check\n\9if type(class) == \"table\" and type(class.instanceof) == \"function\" then\n\9\9return class.instanceof(obj)\n\9end\n\n\9-- metatable check\n\9if type(obj) == \"table\" then\n\9\9obj = getmetatable(obj)\n\9\9while obj ~= nil do\n\9\9\9if obj == class then\n\9\9\9\9return true\n\9\9\9end\n\9\9\9local mt = getmetatable(obj)\n\9\9\9if mt then\n\9\9\9\9obj = mt.__index\n\9\9\9else\n\9\9\9\9obj = nil\n\9\9\9end\n\9\9end\n\9end\n\n\9return false\nend\n\nfunction TS.async(callback)\n\9return function(...)\n\9\9local n = select(\"#\", ...)\n\9\9local args = { ... }\n\9\9return Promise.new(function(resolve, reject)\n\9\9\9coroutine.wrap(function()\n\9\9\9\9local ok, result = pcall(callback, unpack(args, 1, n))\n\9\9\9\9if ok then\n\9\9\9\9\9resolve(result)\n\9\9\9\9else\n\9\9\9\9\9reject(result)\n\9\9\9\9end\n\9\9\9end)()\n\9\9end)\n\9end\nend\n\nfunction TS.await(promise)\n\9if not Promise.is(promise) then\n\9\9return promise\n\9end\n\n\9local status, value = promise:awaitStatus()\n\9if status == Promise.Status.Resolved then\n\9\9return value\n\9elseif status == Promise.Status.Rejected then\n\9\9error(value, 2)\n\9else\n\9\9error(\"The awaited Promise was cancelled\", 2)\n\9end\nend\n\nlocal SIGN = 2 ^ 31\nlocal COMPLEMENT = 2 ^ 32\nlocal function bit_sign(num)\n\9-- Restores the sign after an unsigned conversion according to 2s complement.\n\9if bit32.btest(num, SIGN) then\n\9\9return num - COMPLEMENT\n\9else\n\9\9return num\n\9end\nend\n\nfunction TS.bit_lrsh(a, b)\n\9return bit_sign(bit32.arshift(a, b))\nend\n\nTS.TRY_RETURN = 1\nTS.TRY_BREAK = 2\nTS.TRY_CONTINUE = 3\n\nfunction TS.try(func, catch, finally)\n\9local err, traceback\n\9local success, exitType, returns = xpcall(\n\9\9func,\n\9\9function(errInner)\n\9\9\9err = errInner\n\9\9\9traceback = debug.traceback()\n\9\9end\n\9)\n\9if not success and catch then\n\9\9local newExitType, newReturns = catch(err, traceback)\n\9\9if newExitType then\n\9\9\9exitType, returns = newExitType, newReturns\n\9\9end\n\9end\n\9if finally then\n\9\9local newExitType, newReturns = finally()\n\9\9if newExitType then\n\9\9\9exitType, returns = newExitType, newReturns\n\9\9end\n\9end\n\9return exitType, returns\nend\n\nfunction TS.generator(callback)\n\9local co = coroutine.create(callback)\n\9return {\n\9\9next = function(...)\n\9\9\9if coroutine.status(co) == \"dead\" then\n\9\9\9\9return { done = true }\n\9\9\9else\n\9\9\9\9local success, value = coroutine.resume(co, ...)\n\9\9\9\9if success == false then\n\9\9\9\9\9error(value, 2)\n\9\9\9\9end\n\9\9\9\9return {\n\9\9\9\9\9value = value,\n\9\9\9\9\9done = coroutine.status(co) == \"dead\",\n\9\9\9\9}\n\9\9\9end\n\9\9end,\n\9}\nend\n\nreturn TS", "roblox-ts-model.include.RuntimeLib"))(__env)
end)
__rbx("node_modules", "Folder", "roblox-ts-model.include.node_modules", "roblox-ts-model.include")
__rbx("@rbxts", "Folder", "roblox-ts-model.include.node_modules.@rbxts", "roblox-ts-model.include.node_modules")
__rbx("compiler-types", "Folder", "roblox-ts-model.include.node_modules.@rbxts.compiler-types", "roblox-ts-model.include.node_modules.@rbxts")
__rbx("types", "Folder", "roblox-ts-model.include.node_modules.@rbxts.compiler-types.types", "roblox-ts-model.include.node_modules.@rbxts.compiler-types")
__lua("services", "ModuleScript", "roblox-ts-model.include.node_modules.@rbxts.services", "roblox-ts-model.include.node_modules.@rbxts", function()
	return assert(loadstring("local _=(...)(\"roblox-ts-model.include.node_modules.@rbxts.services\")local script,require=_.script,_.require return setmetatable({}, {\n\9__index = function(self, serviceName)\n\9\9local service = game:GetService(serviceName)\n\9\9self[serviceName] = service\n\9\9return service\n\9end,\n})", "roblox-ts-model.include.node_modules.@rbxts.services"))(__env)
end)
__rbx("types", "Folder", "roblox-ts-model.include.node_modules.@rbxts.types", "roblox-ts-model.include.node_modules.@rbxts")
__rbx("include", "Folder", "roblox-ts-model.include.node_modules.@rbxts.types.include", "roblox-ts-model.include.node_modules.@rbxts.types")
__rbx("generated", "Folder", "roblox-ts-model.include.node_modules.@rbxts.types.include.generated", "roblox-ts-model.include.node_modules.@rbxts.types.include")
__start()
